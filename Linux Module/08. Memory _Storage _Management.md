# Typed Notes on Memory & Storage Management

---

## Understanding Memory Management

### **Overview**
- In the previous class, we explored how the OS manages processes through scheduling. Today, we'll discuss how the OS efficiently allocates memory to processes.  
- **Analogy**: Just like organizing books on a shelf, the OS must allocate memory to different programs so they can run smoothly. Without proper organization, processes may slow down or crash due to insufficient memory.
  
### **Key Topics Covered**:
1. **Memory Allocation**:
   - How the OS ensures memory is distributed among various running programs.
2. **Memory Mapping**:
   - The process of mapping logical addresses used by a program to physical addresses in memory.
3. **Virtual Memory**:
   - A method that enables a system to use more memory than physically available by utilizing disk space.
4. **Garbage Collection**:
   - Automated recovery of unused memory to prevent wastage.
5. **Challenges in Memory Management**:
   - **Swapping**: Moving processes in and out of memory to free space for active tasks.
   - **Fragmentation**: Memory gaps caused by processes using and releasing memory inefficiently.
6. **Strategies for Efficient Memory Management**:
   - **Paging**: Dividing memory into fixed-size blocks.
   - **Segmentation**: Dividing memory into variable-sized blocks based on program structure.

---

### **Types of Memory**

1. **Primary Memory (RAM)**:
   - RAM stores data for programs that the CPU needs to access quickly.
   - **Characteristics**:
     - Fast but temporary (data is lost after a reboot).
     - Smaller in size compared to secondary memory.
   - **Analogy**: Like a temporary workspace where you store things while you're working on them. After a reboot, this workspace is cleared.

2. **Secondary Memory**:
   - Used for long-term data storage and persists after a reboot.
   - **Characteristics**:
     - Larger than RAM, but slower to access.
     - Hard disks, SSDs, and external drives fall into this category.

3.  # üìù Cache Memory & OS Memory Management

## üîπ Cache Memory

* **Definition**: A small, high-speed memory located close to the CPU to store frequently accessed data and instructions.
* **Purpose**: Reduces the time CPU takes to access data compared to fetching from main memory (RAM).

### ‚ö° Characteristics

* **Faster than RAM** (but smaller in size).
* **Located nearest to CPU** ‚Üí sometimes referred to as *CPU memory*.
* **Works on the principle of locality**:

  * **Temporal Locality** ‚Üí recently used data is likely to be used again.
  * **Spatial Locality** ‚Üí data near the recently accessed one is likely to be used.

### üèóÔ∏è Levels of Cache

1. **L1 Cache (Level 1)**

   * Closest to CPU (inside CPU core).
   * Fastest, smallest (e.g., 32‚Äì128 KB per core).
   * Critical for performance.

2. **L2 Cache (Level 2)**

   * Larger than L1 (256 KB ‚Äì 1 MB).
   * Slower than L1, but still faster than RAM.
   * Can be shared between cores (depends on architecture).

3. **L3 Cache (Level 3)**

   * Larger than L2 (2 MB ‚Äì 32 MB).
   * Slower than L2.
   * Usually shared across all cores of a CPU.

üëâ **Trend**:

* **Speed decreases** ‚Üí L1 > L2 > L3
* **Size increases** ‚Üí L1 < L2 < L3
* **Distance from CPU increases** ‚Üí L1 closest, L3 farthest
<img width="2000" height="798" alt="image" src="https://github.com/user-attachments/assets/36f4dfa1-deea-4871-a910-890369ae6ad2" />

---

4. # üìù Virtual Memory & Swap in OS + Monitoring with Script

## üîπ Virtual Memory

* **RAM is limited** in size ‚Üí cannot hold all running processes.
* **Virtual Memory (VM)** allows the OS to give processes the illusion of a much larger memory.
* Achieved by combining:

  * **RAM** (fast, but limited)
  * **Disk (Swap space / Swap file)** (slower, but larger)

üëâ **Flow**:

1. Process requests memory.
2. If RAM is full ‚Üí some inactive pages moved to **swap space**.
3. When needed again ‚Üí swapped back into RAM.
 ---
 ### **Virtual Memory**
- **Why Do We Need Virtual Memory?**
  - Virtual memory expands the system's memory capabilities by using disk space when physical memory (RAM) is exhausted.
  - **Benefits**:
    - Enables multitasking by allowing more processes to run simultaneously.
    - Cost-efficient because it avoids the need to increase the size of RAM, which is expensive.
---
- **Challenges with Virtual Memory**:
  1. **Disk Thrashing**:
     - Occurs when the system spends more time moving data between RAM and virtual memory than executing tasks. This results in a significant performance drop.
     - **Example**: Storing frequently used items in the basement and retrieving them every time you need them wastes a lot of time.
  
  2. **Memory Overcommitment**:
     - Happens when more memory is allocated than is physically available, forcing the system to rely heavily on virtual memory.
     - **Example**: Trying to store 30 books in a drawer that can only hold 10, with the excess books kept elsewhere.
  ---

Absolutely‚Äîhere‚Äôs your complete, **fully detailed**, and **properly ordered** note that keeps **all** the information you provided and adds depth where useful.

---

# üìò Swap Memory & Swapfile ‚Äî Complete Guide

## 1) Concept & Purpose

### 1.1 What is **Swap Memory** (Swap Space)?

* **Definition**: An area on disk (SSD/HDD) that the OS uses as an **extension of RAM** when physical RAM is insufficient.
* **Role**:

  * Temporarily holds **inactive** memory pages so active processes can keep running in RAM.
  * Helps prevent OOM (Out-Of-Memory) kills and crashes.
* **Forms**: Implemented via either a **swap partition** or a **swapfile**.
* **Key point**: Swap space is **much slower** than RAM; it‚Äôs a *safety net*, not a performance booster.

### 1.2 Swap Operations

* **Swap Out**: Move pages **RAM ‚Üí disk (swap)** when RAM pressure rises.
* **Swap In**: Move pages **disk (swap) ‚Üí RAM** when those pages are needed again.
* Heavy, frequent swap in/out (a.k.a. ‚Äúpaging‚Äù) causes **latency** and **disk thrashing**.

---

## 2) Ways to Implement Swap

### 2.1 **Swap Partition**

* **What**: A dedicated disk partition (e.g., `/dev/sda3`) formatted for swap.
* **Pros**:

  * Slightly **better performance** (direct block access).
  * Simple layout; historically common on servers/older systems.
* **Cons**:

  * **Fixed size**; resizing requires repartitioning.
  * Less flexible for dynamic environments.

### 2.2 **Swapfile**

* **What**: A regular file (e.g., `/swapfile`) on a filesystem, marked as swap.
* **Pros**:

  * **Very flexible**‚Äîeasy to add, resize, disable.
  * Simple to set up; perfect for VMs/cloud instances.
* **Cons**:

  * Slight **filesystem overhead** (usually negligible on modern systems).
* **Caveats / FS notes**:

  * Ensure file is not on a network FS (NFS) or a compressed/coW path that disallows swap (older btrfs required special handling).
  * Always set **permissions to 600**.

---

## 3) Practical: Creating & Managing Swap

### 3.1 Check existing swap

```bash
sudo swapon --show       # Lists active swap areas
cat /proc/swaps          # Alternative view
free -h                  # Shows RAM/Swap usage (human-friendly)
```

### 3.2 Create a **1 GB** swapfile (your example)

```bash
sudo fallocate -l 1G /swapfile
sudo chmod 600 /swapfile
sudo mkswap /swapfile
sudo swapon /swapfile
sudo swapon --show
```

### 3.3 Create a **2 GB** swapfile (full example)

```bash
# Create a 2 GB swap file
sudo fallocate -l 2G /swapfile

# Secure it (must be 600 for safety)
sudo chmod 600 /swapfile

# Mark as swap space
sudo mkswap /swapfile

# Enable swap
sudo swapon /swapfile

# Verify
swapon --show
free -h
```

> ‚ö†Ô∏è On filesystems where `fallocate` may create **sparse** files, prefer:

```bash
# Non-sparse creation (safer on all FS types)
sudo dd if=/dev/zero of=/swapfile bs=1M count=2048 status=progress
sudo chmod 600 /swapfile
sudo mkswap /swapfile
sudo swapon /swapfile
```

### 3.4 Make swap **persistent** across reboots

Edit `/etc/fstab`:

```
/swapfile swap swap defaults 0 0
```

**Field breakdown** (kept & expanded):

1. **`/swapfile`** ‚Üí path to the swapfile.
2. **`swap` (2nd field)** ‚Üí filesystem type (swap).
3. **`swap` (3rd field)** ‚Üí ‚Äúmount‚Äù target is swap.
4. **`defaults`** ‚Üí standard options (rw, suid, dev, exec, auto, nouser, async).

   * For swap they are mostly placeholders; swap doesn‚Äôt behave like a normal FS.
   * Useful *extra* options:

     * `pri=<N>` set **priority** if you have multiple swap areas (higher = used first).
     * `nofail` continue boot even if swapfile missing (handy on ephemeral disks).
     * `discard` (SSDs) enable TRIM for swap (or use `--discard` with `swapon`).
5. **`0` (dump)** ‚Üí don‚Äôt back up with `dump`.
6. **`0` (fsck pass)** ‚Üí don‚Äôt `fsck` swap at boot.

### 3.5 Resize a swapfile

```bash
# Disable swap temporarily
sudo swapoff /swapfile

# Resize (example: to 4G)
sudo fallocate -l 4G /swapfile   # or use dd as above for non-sparse
sudo chmod 600 /swapfile
sudo mkswap /swapfile

# Re-enable
sudo swapon /swapfile
sudo swapon --show
```

### 3.6 Remove a swapfile

```bash
sudo swapoff /swapfile
sudo rm /swapfile
# Remove the /etc/fstab line if present
sudo vi /etc/fstab
```

---

## 4) Tuning & Best Practices

### 4.1 **Swappiness**

* Controls how aggressively the kernel swaps (0‚Äì100; default \~60).

```bash
cat /proc/sys/vm/swappiness
sudo sysctl vm.swappiness=10            # temporary
echo "vm.swappiness=10" | sudo tee /etc/sysctl.d/99-swappiness.conf
sudo sysctl --system                    # persist
```

* **Guidelines**:

  * **Desktops/Laptops**: 10‚Äì20 (prefer RAM, less swapping).
  * **Servers/DBs**: lower (1‚Äì10) to avoid latency; depends on workload.
  * **Hibernation users**: ensure swap ‚â• RAM; swappiness doesn‚Äôt change that requirement.

### 4.2 Cache Pressure

* Reclaim inode/dentry caches more aggressively if needed:

```bash
cat /proc/sys/vm/vfs_cache_pressure
sudo sysctl vm.vfs_cache_pressure=100    # default is often 100
```

### 4.3 SSD considerations

* Use `discard` for TRIM:

  * One-time on activation: `sudo swapon --discard /swapfile`
  * Or in `/etc/fstab`: append `,discard`.
* SSD endurance is generally fine for typical swap use on modern drives.

### 4.4 Security

* Always `chmod 600 /swapfile`.
* For sensitive systems, consider **encrypted swap** (e.g., via `cryptsetup`) if RAM may contain secrets that spill to swap.

### 4.5 Sizing (recommendations)

* **Old rule**: swap = 2√ó RAM (dated).
* **Modern**:

  * 8 GB RAM ‚Üí **2‚Äì4 GB** swap.
  * With **hibernation** ‚Üí swap **‚â• RAM**.
  * Servers/cloud ‚Üí size based on workload & OOM risk tolerance.

### 4.6 Overcommitment / Thrashing

* Too much swap or aggressive swappiness can cause **thrashing** (constant paging).
* Monitor `vmstat` and I/O wait (`wa%`) to catch it.

---

## 5) Monitoring & Diagnostics (kept + detailed)

### 5.1 `free -h`

* **Mem**:

  * **total**: installed RAM
  * **used**: total ‚àí free ‚àí buffers/cache
  * **free**: truly free pages (often small)
  * **buff/cache**: page cache + buffers (reclaimable)
  * **available**: *most important*‚Äîestimated memory available **without swapping**
* **Swap**:

  * **total**, **used**, **free**.

### 5.2 `top` / `htop`

* Process view:

  * **VIRT** (virtual mem), **RES** (resident set in RAM), **SHR** (shared).
* Summary line shows **MiB Mem** / **MiB Swap**.
* Watch **%wa** (I/O wait) and **load** when swapping.

### 5.3 `vmstat 1` (your field list kept & expanded)

* **procs**:

  * **r**: runnable processes.
  * **b**: uninterruptible sleep (blocked on I/O).
* **memory**:

  * **swpd**: KB of swap **allocated** (not always actively used).
  * **free**: free RAM (KB).
  * **buff**: buffer memory.
  * **cache**: file cache.
* **swap**:

  * **si**: swap in (KB/s) from disk ‚Üí RAM.
  * **so**: swap out (KB/s) from RAM ‚Üí disk.
* **io**:

  * **bi**: blocks in (reads/s).
  * **bo**: blocks out (writes/s).
* **system**:

  * **in**: interrupts/s.
  * **cs**: context switches/s (CPU saves state and switches tasks every few ms).
* **cpu**:

  * **us**: user time %.
  * **sy**: system (kernel) time %.
  * **id**: idle %.
  * **wa**: I/O wait % (high when disk is the bottleneck).
  * **st**: stolen time % (hypervisor use on VMs).

> Tip: A snapshot is noisy; use short bursts:

```bash
vmstat -SM 1 5     # MB units, 1s interval, 5 samples
```

---

## 6) Automation: Scripts (improved & robust)

### 6.1 Script: Alert when **free memory** low

(Your idea using `awk NR==2 {print $4}` kept but improved to use **MemAvailable**)

```bash
#!/bin/bash
# check_memory.sh
# Alert if available RAM is below a threshold (in MB)

THRESHOLD_MB=500

# Prefer MemAvailable for realism
AVAILABLE_KB=$(awk '/MemAvailable:/ {print $2}' /proc/meminfo)
AVAILABLE_MB=$(( AVAILABLE_KB / 1024 ))

echo "MemAvailable: ${AVAILABLE_MB} MB"

if [ "$AVAILABLE_MB" -lt "$THRESHOLD_MB" ]; then
  echo "‚ö†Ô∏è Low memory: ${AVAILABLE_MB} MB < ${THRESHOLD_MB} MB"
  logger "Low memory alert: ${AVAILABLE_MB}MB available"
  # Optional (be cautious!):
  # sync; echo 3 | sudo tee /proc/sys/vm/drop_caches >/dev/null
fi
```

Run:

```bash
chmod +x check_memory.sh
./check_memory.sh
```

> Legacy variant (your pattern):

```bash
free -m | awk 'NR==2 {print $4}'   # "free" column on Mem line
```

### 6.2 Script: Alert on **swap activity**

* Triggers if swap in/out exceeds a small threshold (e.g., 1‚Äì5 MB/s) for consecutive samples.

```bash
#!/bin/bash
# check_swap_activity.sh
# Alert if vmstat si/so exceed thresholds (MB/s)

SAMPLES=5
INTERVAL=1
THRESHOLD_MBPS=2

# vmstat -SM prints MB
VMOUT=$(vmstat -SM $INTERVAL $SAMPLES | tail -n +3)

ALERT=0
while read -r line; do
  SI=$(echo "$line" | awk '{print $7}')  # si MB/s
  SO=$(echo "$line" | awk '{print $8}')  # so MB/s
  if [ "$SI" -ge "$THRESHOLD_MBPS" ] || [ "$SO" -ge "$THRESHOLD_MBPS" ]; then
    ALERT=1
    break
  fi
done <<< "$VMOUT"

if [ "$ALERT" -eq 1 ]; then
  echo "‚ö†Ô∏è High swap activity detected (‚â• ${THRESHOLD_MBPS} MB/s)"
  logger "High swap activity detected"
fi
```

---

## 7) Troubleshooting & Tips

* **High `si/so` + high `wa%`** ‚Üí Disk-bound swapping; add RAM, tune swappiness down, reduce memory footprint.
* **Plenty of buff/cache ‚Äúused‚Äù** isn‚Äôt bad: Linux will reclaim caches when processes need memory.
* **Multiple swap areas**: Use `pri=` to control which swap is used first.
* **Hibernation**: Requires swap ‚â• RAM, and matching resume configuration.
* **Cloud/ephemeral disks**: Consider `nofail` in `/etc/fstab` for swapfile on ephemeral volumes.
* **Never** place swapfile on network storage, or on FS that forbids it (check your FS documentation).

---

## 8) Quick ‚ÄúMemory Command‚Äù Recap (as in your history)

```bash
clear
free -h
top
cat /proc/meminfo
vmstat 1
swapon --show
```

---

## 9) Summary (at-a-glance)

* **Swap Memory**: disk-backed extension of RAM (safety net, slower than RAM).
* **Swapfile vs Partition**: file is **flexible**; partition is **fixed**, slightly faster.
* **Creation**: `fallocate/dd ‚Üí chmod 600 ‚Üí mkswap ‚Üí swapon`.
* **Persist**: `/etc/fstab` ‚Üí `/swapfile swap swap defaults 0 0`.
* **Monitor**: `free -h`, `top/htop`, `vmstat 1` (watch `si/so`, `wa%`).
* **Tune**: `vm.swappiness`, `vfs_cache_pressure`, SSD `discard`.
* **Scripts**: check **MemAvailable** and **swap activity** for alerts.

---



## üîπ Script to Check Free Memory & Take Action

Here‚Äôs a simple **Bash script** using `free`, `awk`, and conditionals:

```bash
#!/bin/bash

# Threshold (in MB)
THRESHOLD=500

# Get free memory (excluding buffers/cache)
FREE_MEM=$(free -m | awk 'NR==2 {print $4}')

echo "Available Free Memory: ${FREE_MEM} MB"

if [ "$FREE_MEM" -lt "$THRESHOLD" ]; then
    echo "‚ö†Ô∏è Warning: Free memory is below ${THRESHOLD}MB!"
    # Example action: clear cache or send alert
    # Sync + drop caches (use carefully!)
    # sync; echo 3 > /proc/sys/vm/drop_caches
    # Or log warning
    logger "Low memory detected: ${FREE_MEM}MB available"
fi
```

### Explanation

* `free -m | awk 'NR==2 {print $4}'` ‚Üí Extracts **free column** from the 2nd line (RAM).
* Compares with `THRESHOLD`.
* If free memory is less ‚Üí performs an action (alert/log/clean cache).

---

‚úÖ So summary:

* **Virtual Memory** = RAM + Swap.
* **Swap** allows bigger memory illusion but slower.
* **Linux Tools**: `free`, `top`, `vmstat`, `meminfo`.
* **Script** can automate monitoring & alerts.
---

## Efficient Memory Management

Got it üëç You want **very detailed, descriptive notes** on **OS Memory Management (without virtual memory)** ‚Äî not just bullet points, but deeper explanations with examples and step-by-step descriptions. I‚Äôll expand each concept properly.

---

# üìù Detailed Notes on OS Memory Management

## üîπ 1. Memory Allocation

### **a) Static Allocation**

* **Definition**: Memory is assigned **before the program runs** (at compile-time).
* **How it works**:

  * The compiler knows exactly how much memory is needed for each variable, array, or function.
  * Space is reserved in **stack memory** or global/static memory area.
* **Example** (C language):

  ```c
  int arr[100];   // reserves space for 100 integers permanently
  ```
* **Characteristics**:

  * **Fixed size** (cannot grow or shrink).
  * Memory is automatically released when program exits or scope ends.
* **Advantages**:

  * Simple and fast (no runtime overhead).
  * No risk of memory leaks.
* **Disadvantages**:

  * **Memory wastage**: If you reserve 100 elements but use only 10, the rest is wasted.
  * Inflexible: If later you need 200 elements, you cannot expand.

---

### **b) Dynamic Allocation**

* **Definition**: Memory is allocated **during execution (runtime)**, when needed.
* **How it works**:

  * The program requests memory from the OS heap memory.
  * The OS returns the starting address of a free block.
  * The program uses it and later must release it back.
* **Functions in C**:

  * `malloc(size)` ‚Üí allocates memory (uninitialized).
  * `calloc(num, size)` ‚Üí allocates and initializes to 0.
  * `realloc(ptr, size)` ‚Üí resizes previously allocated block.
  * `free(ptr)` ‚Üí frees the memory block.
* **Example** (C):

  ```c
  int *arr = malloc(100 * sizeof(int));  // allocate space for 100 integers
  free(arr);                             // free memory when done
  ```
* **In Python/Java**:

  * No `malloc`/`free`. Memory is allocated automatically when an object is created.
  * Deallocation handled by **Garbage Collector (GC)**.
* **Advantages**:

  * Flexible (allocate exactly what you need, at the right time).
  * Saves memory compared to static allocation.
* **Disadvantages**:

  * Requires extra runtime management.
  * Can lead to **fragmentation** if not managed well.
  * Risk of **memory leaks** (if memory allocated but never freed).
    
### **Memory Allocation Strategies**:
1. **Stack Allocation (Static)**:
   - **Usage**: Memory is allocated when a function is called and deallocated when the function exits.
   - **Example**: Local variables in a function.

2. **Heap Allocation (Dynamic)**:
   - **Usage**: Memory is allocated from a memory pool at runtime, offering flexibility for complex programs with varying resource requirements.
   - **Example**: Programs that dynamically create and destroy objects, such as in object-oriented programming.
---

## üîπ 2. Fragmentation

When memory is allocated and freed dynamically, **free blocks may become scattered or wasted**.

### **a) External Fragmentation**

* **Definition**: Free memory is divided into **scattered non-contiguous blocks**.
* **Problem**: Even if the total free memory is enough, a large block cannot be allocated because memory is broken into small chunks.
* **Example**:

  * Free blocks: 5 KB + 5 KB + 5 KB + 5 KB = 20 KB.
  * Process needs 15 KB.
  * Allocation fails because no single contiguous 15 KB block exists.
* **Solution**:

  * **Compaction** ‚Üí OS shifts processes together to create a large block.
  * But compaction is costly (requires moving data in memory).

---

### **b) Internal Fragmentation**

* **Definition**: Wasted memory **inside an allocated block** when the block is larger than required.
* **Cause**: Memory is divided into fixed-size units (pages/blocks). A process may not fully use the last unit.
* **Example**:

  * Page size = 4 KB.
  * Process needs 10 KB.
  * It gets 3 pages (4 KB + 4 KB + 4 KB = 12 KB).
  * 2 KB wasted inside the last page.
* **Solution**:

  * Reduce block/page size (but smaller blocks increase page table size).

---

## üîπ 3. Segmentation

* **Definition**: A memory management technique where **programs are divided into variable-sized logical segments**.
* **Segments correspond to logical parts** of a program:

  * Code Segment (instructions).
  * Data Segment (global variables).
  * Heap Segment (dynamically allocated).
  * Stack Segment (function calls, local variables).
* **Characteristics**:

  * Each segment has a **base address** (starting point in memory).
  * Each segment has a **limit** (length of segment).
  * CPU uses a **Segment Table** to translate logical ‚Üí physical address.
* **Advantages**:

  * Matches programmer‚Äôs view of memory (modules, arrays, functions).
  * Avoids **internal fragmentation** (since segment size = actual need).
* **Disadvantages**:

  * Causes **external fragmentation** (segments are variable-sized).
  * Requires complex management of base + limit.

---

## üîπ 4. Paging

* **Definition**: A memory management technique where memory is divided into **fixed-size blocks**.

  * Logical memory ‚Üí divided into **Pages** (fixed size, e.g., 4 KB).
  * Physical memory (RAM) ‚Üí divided into **Frames** (same size).
  * A **Page Table** maps each logical page ‚Üí physical frame.
* **How it works**:

  1. Program asks for memory.
  2. OS divides it into pages.
  3. OS finds free frames in RAM and loads the pages.
  4. If a program‚Äôs page is not in RAM, a **page fault** occurs ‚Üí OS loads it from disk.
* **Example**:

  * Program needs 10 KB.
  * Page size = 4 KB.
  * Program split into 3 pages.
  * RAM has free frames: 2, 5, 9 ‚Üí OS maps pages to these frames.
* **Advantages**:

  * **No external fragmentation** (any page can fit in any free frame).
  * Easy memory allocation.
* **Disadvantages**:

  * **Internal fragmentation**: last page may waste space.
  * **Page table overhead**: needs extra memory for mapping.

---

## üîπ 5. Garbage Collection (GC)

Used in **high-level languages** (Python, Java, C#) for **automatic memory management**.

### **How it works**:

1. **Marking** ‚Üí Finds objects that are still in use (reachable).
2. **Sweeping** ‚Üí Frees memory of unreferenced objects.
3. **Compacting** ‚Üí Rearranges memory to remove gaps (reduces fragmentation).

### **Example (Python)**:

```python
x = [1,2,3]
y = x
del x
# object not deleted because y still refers to it
del y
# now no references exist -> garbage collector frees memory
```

### **Advantages**:

* Prevents memory leaks.
* Simplifies development (no manual memory freeing).

### **Disadvantages**:

* Performance overhead (GC pauses program to clean memory).
* Programmer has less control.

---


## Practical Demonstration of Memory Commands

### **Free Command**:
- **Command**: `free -h`
- **Usage**: Displays the total, used, free, shared, cache, and swap memory on the system.
- **Explanation**: 
  - `-h` flag provides output in a human-readable format (MB/GB).

### **Top Command**:
- **Command**: `top`
- **Usage**: Provides real-time memory usage, including CPU, memory, and swap statistics.

### **Proc File System**:
- **File**: `/proc/meminfo`
- **Usage**: Displays detailed information about the system's memory usage, including cache and swap statistics.

### **VMSTAT Command**:
When you run `vmstat 1` (refresh every 1 sec), the output has several columns:

### **(1) procs**

* **`r`** ‚Üí Number of processes waiting for CPU (running or runnable).
* **`b`** ‚Üí Number of processes in uninterruptible sleep (blocked, often waiting for I/O).

---

### **(2) memory**

* **`swpd`** ‚Üí Amount of virtual memory used (KB).
* **`free`** ‚Üí Free physical memory (KB).
* **`buff`** ‚Üí Memory used as **buffers** (temporary storage between I/O devices and RAM).
* **`cache`** ‚Üí Memory used for **file cache** (recently accessed files kept in memory for faster access).

---

### **(3) swap**

* **`si`** ‚Üí Swap **in** (memory moved from disk ‚Üí RAM).
* **`so`** ‚Üí Swap **out** (memory moved from RAM ‚Üí disk).
* ‚ö†Ô∏è Frequent `si`/`so` means system is low on RAM and swapping heavily (bad for performance).

---

### **(4) io (block device I/O)**

* **`bi`** ‚Üí Blocks received from a block device (per sec).
* **`bo`** ‚Üí Blocks sent to a block device (per sec).

---

### **(5) system**

* **`in`** ‚Üí Number of interrupts per second.
* **`cs`** ‚Üí Number of context switches per second.

  * Context switching = CPU pauses one task, saves state, loads another ‚Üí gives illusion of multitasking.

---

### **(6) cpu**

* **`us`** ‚Üí % of CPU time spent on user processes.
* **`sy`** ‚Üí % of CPU time spent on system (kernel) processes.
* **`id`** ‚Üí % of CPU idle time.
* **`wa`** ‚Üí % of CPU waiting for I/O (disk/network).
* **`st`** ‚Üí % of CPU stolen from VM (used by hypervisor).

---


## üîπ 5. Useful Commands

```bash
free -h             # Show free/used memory and swap
top                 # Real-time process & memory usage
cat /proc/meminfo   # Detailed memory statistics
vmstat 1            # System performance stats every 1 sec
```

## Storage Management

Storage management involves organizing and maintaining different types of storage devices to ensure efficient use and data integrity.

### **Historical Storage Devices**:
- **Magnetic Tapes**: Used for data backups.
- **Floppy Disks**: Portable storage with limited capacity.
- **CDs/DVDs**: Optical storage for multimedia and software distribution.
- **Hard Disks (HDD)**: Magnetic disks offering large storage capacity.

### **Modern Storage**:
- **Solid State Drives (SSD)**: Faster, more reliable storage than HDDs due to the lack of moving parts.
- **Cloud Storage**: Remote storage solutions such as Dropbox and Google Drive that allow users to store and access data over the internet.

### **Types of Storage**:

1. **Direct Access Storage**:
   - Examples include **USB drives**, **HDDs**, and **SSDs**, allowing direct access to data stored locally.

2. **Network Storage**:
   - Storage devices accessible over a network, often used by organizations to provide centralized data storage for multiple users. Examples include **Network Attached Storage (NAS)** and **Storage Area Networks (SANs)**.

3. **Cloud Storage**:
   - Provides remote storage solutions where data is stored offsite and can be accessed via the internet. Used by companies for large-scale storage, as seen in data centers.

### **RAID (Redundant Array of Independent Disks)**:
- RAID is a method of combining multiple physical disks into a single logical unit to improve performance and provide redundancy. RAID arrays ensure data is still accessible even if a disk fails.
  - **RAID Levels**: 0 (striping), 1 (mirroring), 5 (striping with parity), and others, offering various balances between performance and fault tolerance.

### **Logical Volume Management (LVM)**:
- **Concept**: LVM aggregates multiple physical volumes (disks) into a **Volume Group (VG)**, which can then be divided into **Logical Volumes (LV)**.
- **Example**:
  - You have three 10GB physical volumes, which are combined into a 30GB volume group. From this, you can create two 15GB logical volumes.

- **Commands**:
  - **`lsblk`**: Lists all block devices.
  - **`sudo pvcreate /dev/sdX`**: Initializes a disk or partition as a physical volume.
  - **`sudo vgcreate VGname /dev/sdX`**: Creates a volume group.
  - **`sudo lvcreate -L SizeG -n LVname VGname`**: Creates a logical volume.
  - **`sudo mount /dev/VGname/LVname /mount-point`**: Mounts a logical volume to a directory.
  - **`sudo lvextend -L +SizeG /dev/VGname/LVname`**: Extends the size of a logical volume.
  - **`sudo lvreduce -L SizeG /dev/VGname/LVname`**: Reduces the size of a logical volume.
