# Typed Notes on Memory & Storage Management

---

## Understanding Memory Management

### **Overview**
- In the previous class, we explored how the OS manages processes through scheduling. Today, we'll discuss how the OS efficiently allocates memory to processes.  
- **Analogy**: Just like organizing books on a shelf, the OS must allocate memory to different programs so they can run smoothly. Without proper organization, processes may slow down or crash due to insufficient memory.
  
### **Key Topics Covered**:
1. **Memory Allocation**:
   - How the OS ensures memory is distributed among various running programs.
2. **Memory Mapping**:
   - The process of mapping logical addresses used by a program to physical addresses in memory.
3. **Virtual Memory**:
   - A method that enables a system to use more memory than physically available by utilizing disk space.
4. **Garbage Collection**:
   - Automated recovery of unused memory to prevent wastage.
5. **Challenges in Memory Management**:
   - **Swapping**: Moving processes in and out of memory to free space for active tasks.
   - **Fragmentation**: Memory gaps caused by processes using and releasing memory inefficiently.
6. **Strategies for Efficient Memory Management**:
   - **Paging**: Dividing memory into fixed-size blocks.
   - **Segmentation**: Dividing memory into variable-sized blocks based on program structure.

---

### **Types of Memory**

1. **Primary Memory (RAM)**:
   - RAM stores data for programs that the CPU needs to access quickly.
   - **Characteristics**:
     - Fast but temporary (data is lost after a reboot).
     - Smaller in size compared to secondary memory.
   - **Analogy**: Like a temporary workspace where you store things while you're working on them. After a reboot, this workspace is cleared.

2. **Secondary Memory**:
   - Used for long-term data storage and persists after a reboot.
   - **Characteristics**:
     - Larger than RAM, but slower to access.
     - Hard disks, SSDs, and external drives fall into this category.

3.  # üìù Cache Memory & OS Memory Management

## üîπ Cache Memory

* **Definition**: A small, high-speed memory located close to the CPU to store frequently accessed data and instructions.
* **Purpose**: Reduces the time CPU takes to access data compared to fetching from main memory (RAM).

### ‚ö° Characteristics

* **Faster than RAM** (but smaller in size).
* **Located nearest to CPU** ‚Üí sometimes referred to as *CPU memory*.
* **Works on the principle of locality**:

  * **Temporal Locality** ‚Üí recently used data is likely to be used again.
  * **Spatial Locality** ‚Üí data near the recently accessed one is likely to be used.

### üèóÔ∏è Levels of Cache

1. **L1 Cache (Level 1)**

   * Closest to CPU (inside CPU core).
   * Fastest, smallest (e.g., 32‚Äì128 KB per core).
   * Critical for performance.

2. **L2 Cache (Level 2)**

   * Larger than L1 (256 KB ‚Äì 1 MB).
   * Slower than L1, but still faster than RAM.
   * Can be shared between cores (depends on architecture).

3. **L3 Cache (Level 3)**

   * Larger than L2 (2 MB ‚Äì 32 MB).
   * Slower than L2.
   * Usually shared across all cores of a CPU.

üëâ **Trend**:

* **Speed decreases** ‚Üí L1 > L2 > L3
* **Size increases** ‚Üí L1 < L2 < L3
* **Distance from CPU increases** ‚Üí L1 closest, L3 farthest
<img width="2000" height="798" alt="image" src="https://github.com/user-attachments/assets/36f4dfa1-deea-4871-a910-890369ae6ad2" />

---

4. # üìù Virtual Memory & Swap in OS + Monitoring with Script

## üîπ Virtual Memory

* **RAM is limited** in size ‚Üí cannot hold all running processes.
* **Virtual Memory (VM)** allows the OS to give processes the illusion of a much larger memory.
* Achieved by combining:

  * **RAM** (fast, but limited)
  * **Disk (Swap space / Swap file)** (slower, but larger)

üëâ **Flow**:

1. Process requests memory.
2. If RAM is full ‚Üí some inactive pages moved to **swap space**.
3. When needed again ‚Üí swapped back into RAM.
 ---
 ### **Virtual Memory**
- **Why Do We Need Virtual Memory?**
  - Virtual memory expands the system's memory capabilities by using disk space when physical memory (RAM) is exhausted.
  - **Benefits**:
    - Enables multitasking by allowing more processes to run simultaneously.
    - Cost-efficient because it avoids the need to increase the size of RAM, which is expensive.
---
- **Challenges with Virtual Memory**:
  1. **Disk Thrashing**:
     - Occurs when the system spends more time moving data between RAM and virtual memory than executing tasks. This results in a significant performance drop.
     - **Example**: Storing frequently used items in the basement and retrieving them every time you need them wastes a lot of time.
  
  2. **Memory Overcommitment**:
     - Happens when more memory is allocated than is physically available, forcing the system to rely heavily on virtual memory.
     - **Example**: Trying to store 30 books in a drawer that can only hold 10, with the excess books kept elsewhere.
  ---
## üîπ Swap Memory
### **What is Swap Memory?**
- **Swap Memory**: An area on a storage device (SSD or hard disk) used by the OS when physical RAM is full. Swap memory works in conjunction with RAM to create **virtual memory**, allowing more processes to run simultaneously.

### **Practical Demonstration: Managing Swap Space**

1. **Check Existing Swap Space**:
   - **Command**: `sudo swapon --show`
   - **Explanation**: Displays details of active swap space. If none exists, it returns nothing.

2. **Create a Swap File**:
   - **Command**: `sudo fallocate -l 1G /swapfile`
   - **Explanation**: Allocates 1GB of space for swap in the root directory.

3. **Secure the Swap File**:
   - **Command**:

 `sudo chmod 600 /swapfile`
   - **Explanation**: Changes permissions to restrict file access, securing it for root use only.

4. **Enable Swap on the File**:
   - **Command**: `sudo mkswap /swapfile`
   - **Explanation**: Marks the file as usable swap space.

5. **Activate the Swap File**:
   - **Command**: `sudo swapon /swapfile`
   - **Explanation**: Enables the swap file for immediate use.

6. **Verify Swap Space**:
   - **Command**: `sudo swapon --show`
   - **Explanation**: Displays the current swap space in use.
     
## üîπ 3. Create a Swap File (Example: 2 GB Swap File)

```bash
# Create a 2 GB swap file
sudo fallocate -l 2G /swapfile

# Secure it
sudo chmod 600 /swapfile

# Mark as swap space
sudo mkswap /swapfile

# Enable swap
sudo swapon /swapfile

# Verify
swapon --show
free -h
```

---
---

## üîπ `/etc/fstab` Swap Entry in Detail

The `/etc/fstab` file (Filesystem Table) defines how disk partitions, devices, and special files (like swap) are mounted at boot.

### Example line:

```
/swapfile swap swap defaults 0 0
```

### Breakdown:

1. **`/swapfile`**

   * Path to the swap file.
   * Instead of a dedicated swap **partition** (e.g., `/dev/sda3`), you can use a regular file (here: `/swapfile`) as swap space.

2. **`swap` (2nd field ‚Üí Filesystem Type)**

   * Specifies the type of filesystem.
   * Since this is a swap area, the type is simply `swap`.

3. **`swap` (3rd field ‚Üí Mount Type)**

   * Again indicates that this entry is used for **swap space** (not a traditional mounted filesystem).

4. **`defaults` (Mount Options)**

   * Shorthand for standard mount options. Includes:

     * **rw** ‚Üí Read/write allowed.
     * **suid** ‚Üí Allow set-user-ID and set-group-ID bits.
     * **dev** ‚Üí Interpret device files.
     * **exec** ‚Üí Allow execution of binaries.
     * **auto** ‚Üí Mount automatically at boot.
     * **nouser** ‚Üí Only root can mount.
     * **async** ‚Üí Perform I/O asynchronously.
   * For swap, these options are mostly placeholders because swap is not accessed like a normal filesystem.

5. **`0` (dump)**

   * Used by the `dump` command (backup utility).
   * `0` = Do not back up this entry (swap does not need backup).

6. **`0` (fsck pass)**

   * Defines filesystem check order at boot by `fsck`.
   * `0` = Do not check (swap areas don‚Äôt require `fsck`).

---
---
### **Issues with Swap Memory**:
- **Overcommitment**: 
  - Swap space should ideally be equal to or smaller than the system‚Äôs RAM. Overcommitting (i.e., allocating too much swap space) can lead to **disk thrashing**, where the system spends excessive time moving data between RAM and swap.

### **Making Swap Space Permanent**:
- Swap memory will be disabled after a reboot unless explicitly set to be permanent.
- **Command**: `vi /etc/fstab`
- Add the following line to `/etc/fstab`:
  ```bash
  /swapfile swap swap defaults 0 0
  ```
  - **Explanation**:
    - `/swapfile`: The file being used as swap.
    - `swap`: File system type.
    - `defaults`: Default mount options.
    - `0 0`: Prevents file system dump and checking at boot.
* **Types**:

  * **Swap Partition** (dedicated space).
  * **Swap File** (a file acting as swap).
* **Example Sizes**:

  * 8 GB RAM ‚Üí 10 GB Swap (older recommendation).
  * Modern: Swap often = RAM size or less (depends on workload).

### Swap Operations

* **Swap In** ‚Üí Data moved from disk (swap) ‚Üí RAM.
* **Swap Out** ‚Üí Data moved from RAM ‚Üí disk (swap).

---
## üîπ Linux Monitoring Commands

1. **free -h** ‚Üí Check free memory & swap in human-readable form.
2. **top** / **htop** ‚Üí Monitor live CPU & memory usage.
3. **/proc/meminfo** ‚Üí Detailed memory statistics.
4. **vmstat** ‚Üí Shows `procs`, `memory`, `swap`, etc.

   Example `vmstat` fields:

   * **`procs`**:

     * `r`: Number of processes waiting for run time (running/runnable).
     * `b`: Processes in uninterruptible sleep.
   * **`swap`**:

     * `si`: Swap in (from disk ‚Üí RAM).
     * `so`: Swap out (from RAM ‚Üí disk).

---

## üîπ Script to Check Free Memory & Take Action

Here‚Äôs a simple **Bash script** using `free`, `awk`, and conditionals:

```bash
#!/bin/bash

# Threshold (in MB)
THRESHOLD=500

# Get free memory (excluding buffers/cache)
FREE_MEM=$(free -m | awk 'NR==2 {print $4}')

echo "Available Free Memory: ${FREE_MEM} MB"

if [ "$FREE_MEM" -lt "$THRESHOLD" ]; then
    echo "‚ö†Ô∏è Warning: Free memory is below ${THRESHOLD}MB!"
    # Example action: clear cache or send alert
    # Sync + drop caches (use carefully!)
    # sync; echo 3 > /proc/sys/vm/drop_caches
    # Or log warning
    logger "Low memory detected: ${FREE_MEM}MB available"
fi
```

### Explanation

* `free -m | awk 'NR==2 {print $4}'` ‚Üí Extracts **free column** from the 2nd line (RAM).
* Compares with `THRESHOLD`.
* If free memory is less ‚Üí performs an action (alert/log/clean cache).

---

‚úÖ So summary:

* **Virtual Memory** = RAM + Swap.
* **Swap** allows bigger memory illusion but slower.
* **Linux Tools**: `free`, `top`, `vmstat`, `meminfo`.
* **Script** can automate monitoring & alerts.
---

## Efficient Memory Management

Got it üëç You want **very detailed, descriptive notes** on **OS Memory Management (without virtual memory)** ‚Äî not just bullet points, but deeper explanations with examples and step-by-step descriptions. I‚Äôll expand each concept properly.

---

# üìù Detailed Notes on OS Memory Management

## üîπ 1. Memory Allocation

### **a) Static Allocation**

* **Definition**: Memory is assigned **before the program runs** (at compile-time).
* **How it works**:

  * The compiler knows exactly how much memory is needed for each variable, array, or function.
  * Space is reserved in **stack memory** or global/static memory area.
* **Example** (C language):

  ```c
  int arr[100];   // reserves space for 100 integers permanently
  ```
* **Characteristics**:

  * **Fixed size** (cannot grow or shrink).
  * Memory is automatically released when program exits or scope ends.
* **Advantages**:

  * Simple and fast (no runtime overhead).
  * No risk of memory leaks.
* **Disadvantages**:

  * **Memory wastage**: If you reserve 100 elements but use only 10, the rest is wasted.
  * Inflexible: If later you need 200 elements, you cannot expand.

---

### **b) Dynamic Allocation**

* **Definition**: Memory is allocated **during execution (runtime)**, when needed.
* **How it works**:

  * The program requests memory from the OS heap memory.
  * The OS returns the starting address of a free block.
  * The program uses it and later must release it back.
* **Functions in C**:

  * `malloc(size)` ‚Üí allocates memory (uninitialized).
  * `calloc(num, size)` ‚Üí allocates and initializes to 0.
  * `realloc(ptr, size)` ‚Üí resizes previously allocated block.
  * `free(ptr)` ‚Üí frees the memory block.
* **Example** (C):

  ```c
  int *arr = malloc(100 * sizeof(int));  // allocate space for 100 integers
  free(arr);                             // free memory when done
  ```
* **In Python/Java**:

  * No `malloc`/`free`. Memory is allocated automatically when an object is created.
  * Deallocation handled by **Garbage Collector (GC)**.
* **Advantages**:

  * Flexible (allocate exactly what you need, at the right time).
  * Saves memory compared to static allocation.
* **Disadvantages**:

  * Requires extra runtime management.
  * Can lead to **fragmentation** if not managed well.
  * Risk of **memory leaks** (if memory allocated but never freed).
    
### **Memory Allocation Strategies**:
1. **Stack Allocation (Static)**:
   - **Usage**: Memory is allocated when a function is called and deallocated when the function exits.
   - **Example**: Local variables in a function.

2. **Heap Allocation (Dynamic)**:
   - **Usage**: Memory is allocated from a memory pool at runtime, offering flexibility for complex programs with varying resource requirements.
   - **Example**: Programs that dynamically create and destroy objects, such as in object-oriented programming.
---

## üîπ 2. Fragmentation

When memory is allocated and freed dynamically, **free blocks may become scattered or wasted**.

### **a) External Fragmentation**

* **Definition**: Free memory is divided into **scattered non-contiguous blocks**.
* **Problem**: Even if the total free memory is enough, a large block cannot be allocated because memory is broken into small chunks.
* **Example**:

  * Free blocks: 5 KB + 5 KB + 5 KB + 5 KB = 20 KB.
  * Process needs 15 KB.
  * Allocation fails because no single contiguous 15 KB block exists.
* **Solution**:

  * **Compaction** ‚Üí OS shifts processes together to create a large block.
  * But compaction is costly (requires moving data in memory).

---

### **b) Internal Fragmentation**

* **Definition**: Wasted memory **inside an allocated block** when the block is larger than required.
* **Cause**: Memory is divided into fixed-size units (pages/blocks). A process may not fully use the last unit.
* **Example**:

  * Page size = 4 KB.
  * Process needs 10 KB.
  * It gets 3 pages (4 KB + 4 KB + 4 KB = 12 KB).
  * 2 KB wasted inside the last page.
* **Solution**:

  * Reduce block/page size (but smaller blocks increase page table size).

---

## üîπ 3. Segmentation

* **Definition**: A memory management technique where **programs are divided into variable-sized logical segments**.
* **Segments correspond to logical parts** of a program:

  * Code Segment (instructions).
  * Data Segment (global variables).
  * Heap Segment (dynamically allocated).
  * Stack Segment (function calls, local variables).
* **Characteristics**:

  * Each segment has a **base address** (starting point in memory).
  * Each segment has a **limit** (length of segment).
  * CPU uses a **Segment Table** to translate logical ‚Üí physical address.
* **Advantages**:

  * Matches programmer‚Äôs view of memory (modules, arrays, functions).
  * Avoids **internal fragmentation** (since segment size = actual need).
* **Disadvantages**:

  * Causes **external fragmentation** (segments are variable-sized).
  * Requires complex management of base + limit.

---

## üîπ 4. Paging

* **Definition**: A memory management technique where memory is divided into **fixed-size blocks**.

  * Logical memory ‚Üí divided into **Pages** (fixed size, e.g., 4 KB).
  * Physical memory (RAM) ‚Üí divided into **Frames** (same size).
  * A **Page Table** maps each logical page ‚Üí physical frame.
* **How it works**:

  1. Program asks for memory.
  2. OS divides it into pages.
  3. OS finds free frames in RAM and loads the pages.
  4. If a program‚Äôs page is not in RAM, a **page fault** occurs ‚Üí OS loads it from disk.
* **Example**:

  * Program needs 10 KB.
  * Page size = 4 KB.
  * Program split into 3 pages.
  * RAM has free frames: 2, 5, 9 ‚Üí OS maps pages to these frames.
* **Advantages**:

  * **No external fragmentation** (any page can fit in any free frame).
  * Easy memory allocation.
* **Disadvantages**:

  * **Internal fragmentation**: last page may waste space.
  * **Page table overhead**: needs extra memory for mapping.

---

## üîπ 5. Garbage Collection (GC)

Used in **high-level languages** (Python, Java, C#) for **automatic memory management**.

### **How it works**:

1. **Marking** ‚Üí Finds objects that are still in use (reachable).
2. **Sweeping** ‚Üí Frees memory of unreferenced objects.
3. **Compacting** ‚Üí Rearranges memory to remove gaps (reduces fragmentation).

### **Example (Python)**:

```python
x = [1,2,3]
y = x
del x
# object not deleted because y still refers to it
del y
# now no references exist -> garbage collector frees memory
```

### **Advantages**:

* Prevents memory leaks.
* Simplifies development (no manual memory freeing).

### **Disadvantages**:

* Performance overhead (GC pauses program to clean memory).
* Programmer has less control.

---


## Practical Demonstration of Memory Commands

### **Free Command**:
- **Command**: `free -h`
- **Usage**: Displays the total, used, free, shared, cache, and swap memory on the system.
- **Explanation**: 
  - `-h` flag provides output in a human-readable format (MB/GB).

### **Top Command**:
- **Command**: `top`
- **Usage**: Provides real-time memory usage, including CPU, memory, and swap statistics.

### **Proc File System**:
- **File**: `/proc/meminfo`
- **Usage**: Displays detailed information about the system's memory usage, including cache and swap statistics.

### **VMSTAT Command**:
When you run `vmstat 1` (refresh every 1 sec), the output has several columns:

### **(1) procs**

* **`r`** ‚Üí Number of processes waiting for CPU (running or runnable).
* **`b`** ‚Üí Number of processes in uninterruptible sleep (blocked, often waiting for I/O).

---

### **(2) memory**

* **`swpd`** ‚Üí Amount of virtual memory used (KB).
* **`free`** ‚Üí Free physical memory (KB).
* **`buff`** ‚Üí Memory used as **buffers** (temporary storage between I/O devices and RAM).
* **`cache`** ‚Üí Memory used for **file cache** (recently accessed files kept in memory for faster access).

---

### **(3) swap**

* **`si`** ‚Üí Swap **in** (memory moved from disk ‚Üí RAM).
* **`so`** ‚Üí Swap **out** (memory moved from RAM ‚Üí disk).
* ‚ö†Ô∏è Frequent `si`/`so` means system is low on RAM and swapping heavily (bad for performance).

---

### **(4) io (block device I/O)**

* **`bi`** ‚Üí Blocks received from a block device (per sec).
* **`bo`** ‚Üí Blocks sent to a block device (per sec).

---

### **(5) system**

* **`in`** ‚Üí Number of interrupts per second.
* **`cs`** ‚Üí Number of context switches per second.

  * Context switching = CPU pauses one task, saves state, loads another ‚Üí gives illusion of multitasking.

---

### **(6) cpu**

* **`us`** ‚Üí % of CPU time spent on user processes.
* **`sy`** ‚Üí % of CPU time spent on system (kernel) processes.
* **`id`** ‚Üí % of CPU idle time.
* **`wa`** ‚Üí % of CPU waiting for I/O (disk/network).
* **`st`** ‚Üí % of CPU stolen from VM (used by hypervisor).

---


## üîπ 5. Useful Commands

```bash
free -h             # Show free/used memory and swap
top                 # Real-time process & memory usage
cat /proc/meminfo   # Detailed memory statistics
vmstat 1            # System performance stats every 1 sec
```

## Storage Management

Storage management involves organizing and maintaining different types of storage devices to ensure efficient use and data integrity.

### **Historical Storage Devices**:
- **Magnetic Tapes**: Used for data backups.
- **Floppy Disks**: Portable storage with limited capacity.
- **CDs/DVDs**: Optical storage for multimedia and software distribution.
- **Hard Disks (HDD)**: Magnetic disks offering large storage capacity.

### **Modern Storage**:
- **Solid State Drives (SSD)**: Faster, more reliable storage than HDDs due to the lack of moving parts.
- **Cloud Storage**: Remote storage solutions such as Dropbox and Google Drive that allow users to store and access data over the internet.

### **Types of Storage**:

1. **Direct Access Storage**:
   - Examples include **USB drives**, **HDDs**, and **SSDs**, allowing direct access to data stored locally.

2. **Network Storage**:
   - Storage devices accessible over a network, often used by organizations to provide centralized data storage for multiple users. Examples include **Network Attached Storage (NAS)** and **Storage Area Networks (SANs)**.

3. **Cloud Storage**:
   - Provides remote storage solutions where data is stored offsite and can be accessed via the internet. Used by companies for large-scale storage, as seen in data centers.

### **RAID (Redundant Array of Independent Disks)**:
- RAID is a method of combining multiple physical disks into a single logical unit to improve performance and provide redundancy. RAID arrays ensure data is still accessible even if a disk fails.
  - **RAID Levels**: 0 (striping), 1 (mirroring), 5 (striping with parity), and others, offering various balances between performance and fault tolerance.

### **Logical Volume Management (LVM)**:
- **Concept**: LVM aggregates multiple physical volumes (disks) into a **Volume Group (VG)**, which can then be divided into **Logical Volumes (LV)**.
- **Example**:
  - You have three 10GB physical volumes, which are combined into a 30GB volume group. From this, you can create two 15GB logical volumes.

- **Commands**:
  - **`lsblk`**: Lists all block devices.
  - **`sudo pvcreate /dev/sdX`**: Initializes a disk or partition as a physical volume.
  - **`sudo vgcreate VGname /dev/sdX`**: Creates a volume group.
  - **`sudo lvcreate -L SizeG -n LVname VGname`**: Creates a logical volume.
  - **`sudo mount /dev/VGname/LVname /mount-point`**: Mounts a logical volume to a directory.
  - **`sudo lvextend -L +SizeG /dev/VGname/LVname`**: Extends the size of a logical volume.
  - **`sudo lvreduce -L SizeG /dev/VGname/LVname`**: Reduces the size of a logical volume.
