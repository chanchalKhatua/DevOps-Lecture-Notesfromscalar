# **Docker Container Networking and Security (Continued)**

This document covers **Docker Networking types**, a **demo on creating a bridge network**, **common interview questions**, and **Docker security best practices**.

---

## **Topics to be discussed:**
1. Docker Networking  
2. Demo: Creating a Network  
3. Interview Questions  
4. Security - Best Practices  

---

# **Docker Networking**

Docker Networking is essential for enabling communication between containers, the host system, and external networks. Docker provides multiple networking modes for different use cases.
---

## üö¢ Docker Networking Overview

- Docker networks are **isolated environments** that allow containers to communicate securely.
- By default, Docker provides several built-in networks: `bridge`, `host`, `none`.
- You can create custom user-defined networks for better control and scalability.

---

## üß† Key Concepts

| Concept                          | Description |
|----------------------------------|-------------|
| **Docker Host**                 | The machine running Docker (e.g., EC2 instance) |
| **Container Internal (CI) Host** | The hostname or internal network of the container |
| **CI External Network**         | External access network for CI (e.g., the internet) |
| **Isolated Networks**           | Networks created to isolate container traffic |

---

## üõ†Ô∏è Docker Networking Commands

### üîç Listing Docker Networks
```bash
docker network ls
```

### üîé Inspecting a Network
```bash
docker network inspect <network-name>
```

### ‚ûï Creating a New Network
```bash
docker network create <network-name>
```

### üîó Connecting a Container to a Network
```bash
docker network connect <network-name> <container-name>
```

### ‚ùå Disconnecting a Container from a Network
```bash
docker network disconnect <network-name> <container-name>
```

### üßπ Removing a Network
```bash
docker network rm <network-name>
```

> ‚ö†Ô∏è Note: A network cannot be removed if any container is connected to it.

### üöÄ Run a Container with a Specific Network
```bash
docker run --network <network-name> <image>
```

### üßΩ Prune Unused Networks
```bash
docker network prune
```
> ‚ö†Ô∏è Be careful: This removes all **unused** networks.

---
### **Types of Docker Networks**

| **Network Type** | **Description**                                    |
|------------------|----------------------------------------------------|
| **Bridge**       | Default network. Containers can communicate within the same host. |
| **Host**         | Removes network isolation between the container and the host. |
| **None**         | Disables networking for a container.               |
| **Overlay**      | Enables communication between containers on different hosts. |
| **Macvlan**      | Gives each container a unique MAC address, making them appear as physical devices on the network. |

---

## **1. Bridge Network**  
A **Bridge Network** is the **default network** created by Docker. Containers on the same bridge network can communicate with each other using **names** or **IP addresses**.
  - Containers on default bridge network can't communicate with host name but can communicate using IP address  
  - Default bridge network doesn't include a dns to resolve container names
---

## üß™ Create Two Containers

```bash
docker run -dit --name container1 alpine sh
docker run -dit --name container2 alpine sh
```

---

## üîç Check IP Addresses of Containers

```bash
docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' container1
docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' container2
```

This will show the internal IPs assigned by Docker to each container.

---

## üåê Bridge Network Behavior

- Containers on the **default bridge network**:
  - ‚úÖ Can communicate with **each other using IP addresses**
  - ‚ùå Cannot resolve **hostnames** of other containers
  - ‚ùå Cannot communicate using container names (no internal DNS)

---

## üîß Test Container Communication

### Access `container1`
```bash
docker exec -it container1 sh
```

### Inside `container1`, try:
```sh
ping <container2-IP>     # ‚úÖ Should succeed
ping container2          # ‚ùå Will fail (no DNS resolution in default bridge)
```

**user-defined bridge networks, container communication, and disabling ICC (Inter-Container Communication)** in Docker:

---

## üß± Create a User-Defined Bridge Network

```bash
docker network create my_bridge
```

- This network allows **automatic DNS resolution**, so containers can communicate using names.

---

## üöÄ Run Containers in the User-Defined Bridge

```bash
docker run -dit --name container1 --network my_bridge alpine sh
docker run -dit --name container2 --network my_bridge alpine sh
```

---

## üîç Inspect Network to See Containers

```bash
docker network inspect my_bridge
```

- You‚Äôll see `container1` and `container2` listed under the `Containers` section.

---

## ‚úÖ Test DNS Resolution (Inside `container1`)

```bash
docker exec -it container1 sh
ping container2   # ‚úÖ Should work using container name
```

---

## ‚ùå What Happens with Default Bridge?

```bash
docker run -dit --name container3 alpine sh
```

- This runs on the **default bridge network**.
- Default bridge **does not support DNS resolution** ‚Üí communication via container name **fails**.
- Also, **ICC (Inter-Container Communication)** can be disabled to restrict even IP-based communication.

---

## üîí Disabling ICC (Inter-Container Communication)

ICC = Inter-Container Communication (controls whether containers on the same bridge can talk to each other)

To disable ICC on the **default bridge**:

### 1. Edit Docker daemon config:

```bash
sudo nano /etc/docker/daemon.json
```

Add:
```json
{
  "bridge": "docker0",
  "icc": false
}
```

### 2. Restart Docker:

```bash
sudo systemctl restart docker
```

---

## üî• Blocking ICC with iptables (Alternative)

```bash
sudo iptables -I DOCKER-USER -i docker0 -o docker0 -j DROP
```

> This inserts a rule that **drops all traffic between containers** on the `docker0` bridge interface.

---
![image](https://github.com/user-attachments/assets/4718990d-f048-4879-af56-41d6c736a087)

 

---

## **2. Host Network**  
In a **Host Network**, the container shares the **host‚Äôs network stack**, removing network isolation.  
- **No Port Isolation**: Containers share the same ports as the host.  
- **Security Issue**: Port conflicts can occur.

### **Command to Use Host Network**:  
```bash
docker run -d --name app --network host <image_name>
```

---

## **3. None Network**  
A **None Network** completely disables networking for a container.  
- Useful for **containers that do not require external communication**.

### **Command to Use None Network**:  
```bash
docker run -d --name app --network none
```

---

## **4. Overlay Network**  
An **Overlay Network** enables communication between containers across **multiple Docker hosts**.  
- Primarily used in **Docker Swarm**.  
- It creates a **virtual network** that spans across nodes.

---

## **5. Macvlan Network**  
A **Macvlan Network** assigns each container a **unique MAC address**, making the containers appear as **separate physical devices** on the network.

### **Command to Create a Macvlan Network**:  
```bash
docker network create -d macvlan --subnet=192.168.1.0/24 --gateway=192.168.1.1 -o parent=eth0 network_name
```

---

# **Demo: Creating a Bridge Network**

### **Step-by-Step Demo Commands**

1. **List All Docker Networks**:  
   ```bash
   docker network ls
   ```

2. **Create a Bridge Network**:  
   ```bash
   docker network create my_bridge_network
   ```

3. **Inspect the Created Network**:  
   ```bash
   docker network inspect my_bridge_network
   ```

4. **Run Containers in the Network**:  
   - **Container 1** (using **nginx**):  
     ```bash
     docker run -d --name container1 --network my_bridge_network nginx
     ```
   - **Container 2** (using **busybox**):  
     ```bash
     docker run -d --name container2 --network my_bridge_network busybox
     ```

5. **Ping Between Containers**:  
   - **Enter Container 1**:  
     ```bash
     docker exec -it container1 /bin/sh
     ```
   - **Ping Container 2**:  
     ```bash
     ping container2
     ```

6. **Disconnect a Network**:  
   ```bash
   docker network disconnect my_bridge_network container1
   ```

---

# **Interview Questions**

### **Q1: How Will You Expose Your Containers Externally?**

**Answer:** There are multiple ways to expose Docker containers:  
1. **Port Binding**:  
   Use the `-p` option to bind the container port to a host port.  
   ```bash
   docker run -d -p 8080:80 nginx
   ```

2. **Docker Compose**:  
   Define port binding in the `docker-compose.yml` file.  
   ```yaml
   ports:
     - "8080:80"
   ```

3. **Swarm Services**:  
   Use the `--publish` option to expose services.  
   ```bash
   docker service create --name my_service --publish published=8080,target=80 nginx
   ```

4. **Proxy Servers**:  
   Use **NGINX** or **HAProxy** as a **reverse proxy** to handle requests to the container.

---

### **Q2: What Are Common Issues with Docker Containers and How Do You Troubleshoot Them?**

| **Issue**                   | **Troubleshooting Steps**                       |
|-----------------------------|-------------------------------------------------|
| **Connectivity Issues**      | Check container network settings.              |
| **DNS Resolution**           | Check if the container can resolve DNS names.  |
| **Port Binding Conflicts**   | Use `netstat -tupln` to check for conflicts.   |
| **Performance Degradation**  | Monitor resource usage and network traffic.    |

### **Troubleshooting Commands**
1. **Inspect Container Networks**:  
   ```bash
   docker network inspect <network_name>
   ```

2. **Check Connectivity Using Ping**:  
   ```bash
   docker exec -it <container_id> ping <target>
   ```

3. **Check DNS Settings**:  
   - By default, Docker uses the **host DNS settings**.  
   - To change the DNS:  
     ```bash
     docker run -d --name my_container --dns 8.8.8.8 nginx
     ```

4. **Check Ports in Use**:  
   ```bash
   netstat -tupln
   ```

5. **Check Container Logs**:  
   ```bash
   docker logs <container_id>
   ```

6. **Monitor Network Traffic Using tcpdump**:  
   ```bash
   tcpdump -i eth0
   ```

---

# **Security - Best Practices**

### **1. Signing Images**  
- Use **signed images** to ensure the authenticity of Docker images.  
- **Command to Check Image Signature**:  
  ```bash
  docker trust inspect --pretty nginx
  ```

---

### **2. MTLS (Mutual TLS Authentication)**  
**MTLS** ensures that both the client and server authenticate each other using **certificates**.

#### **Steps to Enable MTLS:**
1. **Generate Certificates**  
   - Create **CA**, **server**, and **client certificates**.

2. **Configure Docker Daemon**  
   - Modify the **`daemon.json`** file:  
     ```json
     {
         "tls": true,
         "tlscacert": "/path/to/ca.pem",
         "tlscert": "/path/to/server-cert.pem",
         "tlskey": "/path/to/server-key.pem",
         "tlsverify": true
     }
     ```

3. **Restart Docker Daemon**  
   ```bash
   systemctl restart docker
   ```

---

### **3. Generating a Certificate (Practical Example)**

#### **Steps to Generate Certificates:**
1. **Generate CA Key & Certificate**  
2. **Generate Server Key & Certificate**  
3. **Sign the Server Certificate**  
4. **Generate Client Key & Certificate**  
5. **Sign the Client Certificate**

# **Summary of Key Commands**

| **Command**                        | **Description**                                    |
|------------------------------------|----------------------------------------------------|
| `docker network create`             | Creates a new Docker network.                     |
| `docker network ls`                 | Lists all Docker networks.                        |
| `docker network inspect`            | Inspects a specific network.                      |
| `docker run --network <network>`    | Runs a container in a specific network.           |
| `netstat -tupln`                    | Lists all active ports and services.              |
| `docker trust inspect --pretty`     | Checks the signing authority of a Docker image.   |

---

# **Conclusion**

This session covered **Docker Networking**, a **demo on creating networks**, common **interview questions**, and **security best practices**.  
Make sure to practice using **networks and security features** to strengthen your understanding of Docker.
